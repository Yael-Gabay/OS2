# OS2
In this exercise we were asked to deal with the SIMPLE HTTP communication protocol, a protocol which is actually a very limited version of HTTP.
This protocol contains two instructions GET and POST.
## Part 1- server:
We were asked to write a server that supports this protocol.
The server receives only one parameter (in argv) describing the root directory of the server. The server supports multiple simultaneous downloads using multiple processes. This server is based on TCP communication for transferring data on the Internet.

### Now we will explain about the server code:
At the beginning of the code we defined constants that affect the conduct of the program.
+ PORT: This constant indicates the port where the server is ready and waiting to receive requests from clients to connect. This is the initial step in the process of establishing a TCP connection between a server and a client. Every client that wants to connect to the server must use the same port to connect.
+ BACKLOG: This constant specifies the size of the connection request queue. When there are many clients who want to connect to the server at the same time, BACKLOG indicates the maximum size of the queue where the requests are waiting to be processed.
+ BUFFER_SIZE: This constant specifies the size of the buffer in which the program receives and sends data over the network. It does this with a certain amount of data that is defined in advance. The buffer size indicates the amount of data that can be read or written at a time.

Then we defined some functions that are needed in the server program:            
+ *void handle_client(int client_socket, char * root_dir):* The handle_client function handles the client that is connected to the server. The function receives the client's socket ID and the server's primary path. Initializes a character array with the size of BUFFER_SIZE and resets it. First receives data from the appropriate socket of the client, enters the created array and returns a recv value if the call was successful then continues to process the data received from the client otherwise prints an error and exits the function. The function breaks down the request by spaces and separates the first field (the request action, GET or POST) and the second field (the path of the file or resource required for the request). If the first operation in the request is GET, it receives the desired path and calls the function handle_get_request in order to handle the request. If the first action in the request is POST, it receives the desired path and calls the handle_post_request function to handle the request.
+ *void handle_get_request(int client_socket, char * remote_path, char * root_dir):* This function handles the GET instruction.
First establish the full file path, this function receives the client's socket ID (client_socket), the requested file path (remote_path) and the server's main path (root_dir). It uses these two paths to build the full path of the file to be read from the server. This is done by concatenating the two paths using the snprintf function. After the full path is built, the function tries to open the file using the open function. The read opens a read-only file (O_RDONLY). If the opening failed (the open function returns a negative value), the function prints an error, and if the reason was that the file was not found, it sends a "404 FILE NOT FOUND" error response. If the opening was successful, the function uses the fstat function to get the file details (its size and other details). If the fstat call fails, the function sends an error response to the client. If all tests pass successfully, the function prepares the response head using the snprintf function. The header contains the correct code "200 OK" and the length of the requested file. The response header also incorporates the file length using the file_stat.st_size variable. It then sends the response header to the client using the send_response function. After the response header is sent, the function uses sendfile to send the contents of the file to the client. This function receives the file ID, the client's socket ID, and the location in the file to send the data from. 
+ *void handle_post_request(int client_socket, char * remote_path, char * root_dir):* The function receives the client's socket ID (client_socket), the file path where the received data should be saved (remote_path) and the main path of the server (root_dir). It uses the given file path in order to build the full path of the file in which the resulting data should be saved. This is done by concatenating the two paths using the snprintf function. The function allocates the data received from the client from the recv function and puts it into the buffer character set. If the read failed, the function prints an error using perror("recv") and terminates the function. After that, the function breaks down the data received from the client from the buffer according to separate lines with the help of the strtok function. Each line contains encrypted data in BASE64 format. The function then uses the OpenSSL library to decrypt the encrypted data using the BIO_new, BIO_new_mem_buf, and BIO_push functions. the corresponding file in write-only mode (wb) using the fopen function. If the opening failed, it prints an error and sends an error response to the client using the send_response function. If the opening was successful, it uses the fwrite function to write the decoded data to the file. The fclose function releases all the resources it used using the BIO_free_all function, and sends a confirmation response to the client "200 OK" using the send_response function.
+ *void send_response(int client_socket, char * response):* This function is used to send responses to a client using a TCP connection. It receives the client's socket ID (client_socket) and the response we want to send, represented as a string (response).
It uses the send function to send the response to the client. The function output is not required here. That is, the function simply sends the prepared response to the client through the layered TCP protocol that exists between the server and the client.

### The main program: 
This function is the main program of a simple TCP server that listens for connected requests, handles them, and provides an appropriate response. The function defines a variable root_dir that represents the main folder where the server will look for the files.
Additionally defines variables such as server_socket, client_socket, server_addr and client_addr, which are used to manage the network connections and transfer the information between them. A new connection is opened using the socket function. We connect and enable with a specific connection using bind. The server starts listening for new connections using listen. If the operation fails, the program will exit with an error code.
The function continues in an infinite loop that continues to the area of ​​receiving new connections.
When a new connection is received, it is handled using the accept function. For each new connection, a new child process is created using fork. In the child process, the function closes the server connection and calls the handle_client function that handles requests from the client. After treatment, the child process is closed. The program will continue to listen for new connections.

### BASE64
BASE64 encoding is used in the POST instruction. In POST requests, the data is transferred more confidentially, unlike a GET request in which the file is transferred directly. and therefore may be encoded in BASE64. This encoding is an encoding method used to convert binary data into text that consists of ASCII characters. The encoding uses 64 different characters, including upper and lower case English letters, numbers, and special characters, so that any type of data can be displayed using characters that are part of the standard ASCII character set.

## Part 2- client:
When downloading a file whose extension is .list it has a list of files. We will be interested in downloading all the files at the same time. In order to support simultaneous downloading, we will open several connections to the same server at the same time and receive data in all of them. We will support receiving data on several connections at the same time with the help of async i/o. 
In this part we were asked to write a textual client that receives one parameter - what should be downloaded, with the help of argv The client will ask the server for the requested file. If a .list file was requested, it will request all the files appearing in the list at the same time.
In the LIST files can appear at several addresses and the downloaded files will have to be base64 decoded and saved in a standard format.

### Now we will explain about the client code:
At the beginning of the code we defined constants that affect the conduct of the program.
+ PORT: Used to define the port where the client connects to the server.
+ BUFFER_SIZE: The size of the buffer used for reading and writing from or to the server.

Then we defined some functions that are needed in the client program:
+ *void alloc_buffer(uv_handle_t * handle, size_t suggested_size, uv_buf_t * buf):* This function is used to allocate memory for the buffer where the data to be read from the stream will be allocated. It gets the recommended size for the buffer (suggested_size) and allocates memory for it using the malloc operation, then the function sets the uv_buf_t to point to the allocated buffer.
+ *void on_connect(uv_connect_t * connection, int status):* This function is activated as a response to the successful connection event. The connection parameter is a pointer to a structure of type uv_connect_t, which contains information about the connection. The status parameter indicates the connection result- if the connection was successful, status will be 0, otherwise there will be a non-zero value indicating a specific error. After that, the function uv_read_start activates a process of reading data from the connection and receives from it parameters that indicate the connection itself (connection->handle), the function that will be used to allocate memory for the data being read (alloc_buffer), and the function that will be executed when the data is read (on_read).
+ *void on_read(uv_stream_t * stream, ssize_t nread, const uv_buf_t * buf):* The uv_read_start function starts the reading from the stream linked to the connection and defines the alloc_buffer function as an allocation function for new buffers and in addition it activates on_read whose purpose is to process data received from the stream given to it as a parameter.
The on_read function is called when reading from the connection is finished or when an error occurs in reading. It receives the stream from which the read was received, the amount of data read (nread), and the buffer in which the data was received (buf). The function first checks if the read was successful (in this case nread will be greater than zero). If so, it passes the data to the handle_response function in order to process it and frees the buffer it used. Finally the function closes the stream and activates the on_close function.
+ *void on_write(uv_write_t * request, int status):* The on_write function is a callback function that is activated when data is written to the stream. It receives two parameters:
uv_write_t *request- This is the data structure that contains the details of the write request sent and int status- indicates the result of writing. If the write was successful, status will be 0. If there is a problem with the write, status will contain an appropriate error code and the function will free the memory received for the request using the free(request) function.
+ *void on_close(uv_handle_t * handle):* This function is executed when the connection to the server of type uv_handle_t is closed. The function prints a message that says "Connection closed".
+ *void send_request(uv_stream_t * stream, const char * request):* This function uses the libuv library to write data to a particular stream. It accepts as arguments the stream to write (uv_stream_t *stream) and the request to send (const char *request). The function creates a write_req_t type structure, which is a structure adapted for library communication. The structure contains functions and variables that are used to monitor the network connections and to read and write data from or to the server. Finally, the function calls uv_write to perform the write using the given stream.
+ *void handle_response(const char * response, const char * server_ip):* This function receives a response parameter from the server and its IP address and performs a simple test to determine if the response is a list of files or a simple file. If the response contains the ".list" notation, it accepts that the response is a list of files, so it calls the handle_file_list function. Otherwise, it contains the contents of the file itself, so simply prints the contents read from the response.
+ *void handle_file_list(const char * file_list, const char * server_ip, uv_loop_t * loop, uv_tcp_t * socket):* This function handles a list of files sent from the server. It receives the list as a parameter and the IP address of the server, the libuv event loop (loop), and the TCP socket where the connection with the server is managed.
For each file in the list: It copies the original list (file_list) to a new string (file_list_copy) using the strdup function. The function uses strtok to break the string into separate filenames. For each filename, it builds a GET request to the server to get its content. The request is made using the send_request function.

### The main program: 
First the program applies values ​​to the server_ip and file_path variables that represent the IP address of the server and the path to the requested file on the server.
After that, prepares a struct sockaddr_in type structure that represents the server address and the port to which the connection will be made, and creates a new TCP connection using the uv_tcp_init function. Using the uv_ip4_addr function, it fills the dest structure with the details of the server's IP address and port.
The program establishes a real TCP connection to the server using the uv_tcp_connect function, where it passes the connection structure, the newly created socket structure, and the server address.
The program constructs the request to the server using the snprintf function, which contains the requested file path and the server address, and sends it to the server using the send_request function.
Finally, it runs libuv's main loop using the uv_run function, which handles receiving and handling IO-related events.

Below is a photograph of a running example of the program:
![WhatsApp Image 2024-02-18 at 14 33 08](https://github.com/Yael-Gabay/OS2/assets/93923600/237b80aa-35cd-44b7-a9d3-86374c70629a)



### Collaborators
- *Noam David*
- *Yael Gabay*
